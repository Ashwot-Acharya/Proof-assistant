@article{Alrubyli2021,
   abstract = {The purpose of this paper is to give an easy to understand with step-by-step explanation to allow interested people to fully appreciate the power of natural deduction for first-order logic. Natural deduction as a proof system can be used to prove various statements in propositional logic, but we will see its extension to cover quantifiers which gives it more power over propositional logic in solving more complex, real-world problems. We started by going over logical connectives and quantifiers to agree on the symbols that will be used throughout the paper, as some authors use different symbols to refer to the same thing. Besides, we showed the inference rules that are used the most. Furthermore, we presented the soundness and completeness of natural deduction for first-order logic. Finally, we solved examples ranging from easy to complex to give you different circumstances in which you can apply the proof system to solve problems you may encounter. Hopefully, this paper will be helpful makes the subject easy to understand.},
   author = {Alrubyli and Yazeed},
   month = {8},
   title = {Natural Deduction Calculus for First-Order Logic},
   url = {http://arxiv.org/abs/2108.06015},
   year = {2021}
}
@techReport{Pfenning2004,
   author = {Frank Pfenning},
   title = {This includes revised excerpts from the course notes on Linear Logic (Spring 1998) and Computation and Deduction},
   url = {http://www.cs.cmu.edu/~fp/courses/atp/.},
   year = {2004}
}
@article{Rojas2015,
   abstract = {This paper is a concise and painless introduction to the $λ$-calculus. This formalism was developed by Alonzo Church as a tool for studying the mathematical properties of effectively computable functions. The formalism became popular and has provided a strong theoretical foundation for the family of functional programming languages. This tutorial shows how to perform arithmetical and logical computations using the $λ$-calculus and how to define recursive functions, even though $λ$-calculus functions are unnamed and thus cannot refer explicitly to themselves.},
   author = {Raul Rojas},
   month = {3},
   title = {A Tutorial Introduction to the Lambda Calculus},
   url = {http://arxiv.org/abs/1503.09060},
   year = {2015}
}
@inproceedings{Geuvers2009,
   author = {Herman Geuvers},
   doi = {10.1007/978-3-642-03153-3_1},
   isbn = {3642031528},
   issn = {03029743},
   booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   pages = {1-56},
   title = {Introduction to type theory},
   volume = {5520 LNCS},
   year = {2009}
}
@techReport{How,
   abstract = {Dedicated to H. B. Curry on the occasion of his 80th birthday. The following consists of notes which were privately circulated in 1969. Since they have been referred to a few times in the literature, it seems worth while to publish them. They have been rearranged for easier reading, and some inessential corrections have been made. The ultimate goal was to develop a notion of construction suitable for the interpretation of intuitionistic mathematics. The notion of construction developed in the notes is certainly too crude for that, so the use of the word construction is not very appropriate. However, the terminology has been kept in order to preserve the original title and also to preserve the character of the notes. The title has a second defect; namely, a type should be regarded as a abstract object whereas a formula is the name of a type. In Part I the ideas are illustrated for the intuitionistic propositional calculus and in Part II (page 6) they are applied to Heyting arithmetic. I Intuitionistic propositional calculus H. Curry (1958) has observed that there is a close correspondence between axioms of positive implicational propositional logic, on the one hand, and basic combina},
   author = {W H Howard},
   title = {The formulae-as-types notion of construction},
   year = {1969}

}

@misc{martinlof1972intuitionistic_theory,
  author       = {Per Martin-Löf},
  title        = {An Intuitionistic Theory of Types},
  year         = {1972},
  howpublished = {Unpublished preprint; included in *Twenty‑Five Years of Constructive Type Theory*, OUP 1998},
  note         = {\url{https://archive-pml.github.io/martin-lof/pdfs/An-Intuitionistic-Theory-of-Types-1972.pdf}}
}
@misc{Geuvers20091,
   abstract = {In this paper I will discuss the fundamental ideas behind proof assistants: What are they and what is a proof anyway? I give a short history of the main ideas, emphasizing the way they ensure the correctness of the mathematics formalized. I will also briefly discuss the places where proof assistants are used and how we envision their extended use in the future. While being an introduction into the world of proof assistants and the main issues behind them, this paper is also a position paper that pushes the further use of proof assistants. We believe that these systems will become the future of mathematics, where definitions, statements, computations and proofs are all available in a computerized form. An important application is and will be in computer supported modelling and verification of systems. But there is still a long road ahead and I will indicate what we believe is needed for the further proliferation of proof assistants. © Printed in India.},
   author = {H. Geuvers},
   doi = {10.1007/s12046-009-0001-5},
   issn = {02562499},
   issue = {1},
   journal = {Sadhana - Academy Proceedings in Engineering Sciences},
   keywords = {Formalized mathematics,Logic,Proof assistant,Software correctness,Verification},
   month = {2},
   pages = {3-25},
   title = {Proof assistants: History, ideas and future},
   volume = {34},
   year = {2009}
}
@techReport{depPUlf,
   author = {Ulf Norell and James Chapman},
   title = {Dependently Typed Programming in Agda}
}
@techReport{Lean,
   abstract = {Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specied axiomatic proofs. Lean is an ongoing and long-term eort, but it already provides many useful components , integrated development environments, and a rich API which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.},
   author = {Leonardo De Moura and Soonho Kong and Jeremy Avigad and Floris Van Doorn and Jakob Von Raumer},
   title = {The Lean Theorem Prover (system description)},
   url = {http://leanprover.github.io}
}
@online{rocq_manual,
  author    = {Rocq Prover Development Team},
  title     = {Rocq Prover Reference Manual: Introduction and Contents},
  year      = {2025},
  url       = {https://rocq-prover.org/doc/V9.0.0/refman/index.html},
  note      = {Accessed: 2025-08-05}
}

@online{rocq_tactics,
  author    = {Rocq Prover Development Team},
  title     = {Rocq Prover Reference Manual: Tactics},
  year      = {2025},
  url       = {https://rocq-prover.org/doc/V9.0.0/refman/proof-engine/tactics.html},
  note      = {Accessed: 2025-08-05}
}

@online{rocq_core_language,
  author    = {Rocq Prover Development Team},
  title     = {Rocq Prover Reference Manual: Core Language},
  year      = {2025},
  url       = {https://rocq-prover.org/doc/V9.0.0/refman/language/core/index.html},
  note      = {Accessed: 2025-08-05}
}

@article{type_checking,
  author    = {Sozeau, Matthieu and Forster, Yannick and Lennon-Bertrand, Meven and Nielsen, Jakob and Tabareau, Nicolas and Winterhalter, Th\'{e}o},
  title     = {Correct and Complete Type Checking and Certified Erasure for Coq, in Coq},
  journal   = {J. ACM},
  year      = {2025},
  month     = jan,
  volume    = {72},
  number    = {1},
  issue_date= {February 2025},
  articleno = {8},
  numpages  = {74},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  issn      = {0004-5411},
  url       = {https://doi.org/10.1145/3706056},
  doi       = {10.1145/3706056},
  abstract  = {Coq is built around a well-delimited kernel that performs type checking for definitions in a variant of the Calculus of Inductive Constructions (CIC). Although the metatheory of CIC is very stable and reliable, the correctness of its implementation in Coq is less clear. Indeed, implementing an efficient type checker for CIC is a rather complex task, and many parts of the code rely on implicit invariants which can easily be broken by further evolution of the code. Therefore, on average, one critical bug has been found every year in Coq. This article presents the first implementation of a type checker for the kernel of Coq (without the module system, template polymorphism and η-conversion), which is proven sound and complete in Coq with respect to its formal specification. Note that because of G\"{o}del’s second incompleteness theorem, there is no hope to prove completely the soundness of the specification of Coq inside Coq (in particular strong normalization), but it is possible to prove the correctness and completeness of the implementation assuming soundness of the specification, thus moving from a trusted code base (TCB) to a trusted theory base (TTB) paradigm. Our work is based on the MetaCoq project which provides meta-programming facilities to work with terms and declarations at the level of the kernel. We verify a relatively efficient type checker based on the specification of the typing relation of the Polymorphic, Cumulative Calculus of Inductive Constructions (PCUIC) at the basis of Coq. It is worth mentioning that during the verification process, we have found a source of incompleteness in Coq’s official type checker, which has then been fixed in Coq 8.14 thanks to our work. In addition to the kernel implementation, another essential feature of Coq is the so-called extraction mechanism: the production of executable code in functional languages from Coq definitions. We present a verified version of this subtle type and proof erasure step, therefore enabling the verified extraction of a safe type checker for Coq in the future.},
  keywords  = {Proof assistants, type checker, certification}
}

@online{lean_functional_programming,
  author    = {David Thrane Christiansen},
  title     = {Functional Programming in Lean},
  year      = {2025},
  url       = {https://lean-lang.org/functional_programming_in_lean/Introduction/},
  note      = {Creative Commons Attribution 4.0 International License. Accessed: 2025-08-05}
}
@online{lean_theorem_proving,
  author    = {{Lean Community}},
  title     = {Theorem Proving in Lean 4: Introduction},
  year      = {2025},
  url       = {https://lean-lang.org/theorem_proving_in_lean4/Introduction/},
  note      = {Accessed: 2025-08-05}
}
