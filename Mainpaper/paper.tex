\documentclass[12pt]{article}

% ======== Packages =========
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{cite}
\usepackage{geometry}
\usepackage{bussproofs}
\usepackage{tasks}
\geometry{a4paper, margin=1in}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}

\title{Working Principles of Proof Assistants and Formalization of some proofs in Agda}
\author{Bishesh Bohora, Supreme Chaudhary, Ashwot Acharya \\
\small Kathmandu University 
\small \texttt{}
}
%mention supervisor
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}

\section{Foundations}
This section sheds light upon some fundamental concept on which Proof Assistants work along with how a proof should be written so that it can be mechanically verified.
\subsection{Logic Foundations}
This works assumes prior knowledge of Propositional and Predicate Logic. And we refer to both together as \textbf{Classical}.
\subsubsection{Natural Deduction}
The propositions or formulas in Propositional Logic can be verified or proved simply by constructing their truth tables. But for logically complex propositions or propositions with many atomic statements, it becomes difficult to construct a truth table. With predicates, this becomes impossible. Therefore, to mitigate this we adhere to a basic set of inference rules with which we derive conclusions from assumptions in step by step, structured manner. The rule based system which allows us to reason about logical structure of propositions is known as \textbf{Natural Deduction}. \\
With the rules in Section 2.3 of \cite{Alrubyli2021}  we now present examples on how a proof is carried out with Natural Deduction for Classical Logic.

\newtheorem{example}{Example}[section] 
\begin{example}
    \label{contra}
    \textbf{$(A \land\neg A) \to \bot $ }
  
    By negation introduction we can write $\neg A$ as $A \to \bot$

    $(A \land (A \to \bot)) \to \bot$

    \begin{prooftree}
        \AxiomC{$[A]$}
        \AxiomC{$[A \to \bot]$}
        \RightLabel{\scriptsize$\to$E}
        \BinaryInfC{$\bot$}
    \end{prooftree}
    
    

    

\end{example}

\begin{example}
    \label{lem}
    Proof for Law of Excluded Middle ($P \lor \neg P$)\\
    Note that Example \ref{contra}'s result is used here.
    \begin{prooftree}
\AxiomC{$[P]$}
\RightLabel{\scriptsize$\lor$I$$}
\UnaryInfC{$P \lor \neg P$}
\AxiomC{$[\neg (P \lor \neg P)]$}
\RightLabel{\scriptsize$\bot$}
\BinaryInfC{$\bot$}
\RightLabel{\scriptsize$\neg I$}
\UnaryInfC{$\neg P$}
\RightLabel{\scriptsize$\lor$I$$}
\UnaryInfC{$P \lor \neg P$}
\AxiomC{$[\neg (P \lor \neg P)]$}
\RightLabel{\scriptsize$\bot$}
\BinaryInfC{$\bot$}
\RightLabel{\scriptsize$\neg$I$$}
\UnaryInfC{$\neg \neg (P \lor \neg P)$}
\RightLabel{\scriptsize$\neg\neg$E}
\UnaryInfC{$P \lor \neg P$}
\end{prooftree}
\end{example}



\begin{example}
    $$ \forall x (A(x) \to B(x) ) , A(s)  \vdash \exists  x B(x) $$

    \begin{prooftree}
        \AxiomC{$[ \forall x (A(x) \to B(x))]$}
        \AxiomC{$[A(s)]$}
        \RightLabel{\scriptsize $\forall E$}
        \BinaryInfC{$A(s) \to B(s)$}
        \RightLabel{\scriptsize $\to E$}
        \UnaryInfC{B(s)}
        \RightLabel{\scriptsize $\exists I$}
        \UnaryInfC{$\exists x B(x)$}
    \end{prooftree}

\end{example}

The \textbf{soundness} and \textbf{completeness} of this system are discussed in Section 3.1 and 3.2 \cite{Alrubyli2021}. 
\subsubsection{Intuitionstic Logic}
Intuitionstic Logic was introduced to formalize the constructive method to do mathematics. Unlike in Classical Logic a statement is True if we can construct a proof for it and to claim a statement is False, again a proof of its falsity is required. This allows the case that some statements are not provable. 
To show something exists one must provide an method or algorithm to construct it. Proof Assistants leverage this fact.
The constructive view of doing mathematics gives a stricter criteria. Intuitionstic  Logic can be obtained by restricting certain parts of Classical Logic, like the Law of Excluded Middle.

For inference rules for Natural Deduction in Intuitionstic Logic See 2.1 \cite{Pfenning2004}, here the language is slightly different from above, we have
\\
\textit{Terms} \quad $t ::= x \mid a \mid f(t_1, \ldots, t_n)$
\\
\textit{Propositions} \quad
$A ::= P(t_1, \ldots, t_n) \mid A_1 \land A_2 \mid A_1 \supset A_2 \mid A_1 \lor A_2 \mid \neg A \mid \bot \mid \top \mid \forall x. A \mid \exists x. A$

 The main focus is that this new set of rules does not contain the double negation rule which is present in what we introduced in Section 2.1.1. \textbf {Example \ref{lem}} uses the Double negation rule in its proof, which we don't have now. This agrees to that Law of Excluded Middle does not work in Intuitionstic Logic. The method of proof by contradiction also relies on this rule, so constructivists omit it.\\
These rules are revised with localized hypotheses i.e we use the above rules under a set of premises, and refer the derivation as "derived under a context". With introduction of contexts 
$$Contexts  \ \Gamma ::= .|\Gamma,u: A$$
[See 2.3 \cite{Pfenning2004}]


\subsection{$\lambda$ - Calculus and Type Theory} 

\subsubsection{Untyped $\lambda$-Calculus}
It is a model of computation introduced by Alzano Church. It consists of construction and operations on lambda terms. 
Among the lambda terms we have,
\begin{enumerate}
    \item Variables : $x,y,z ...$ are lambda terms
    \item Application : If E,F are lambda terms EF is a lambda term 
    \item Abstraction : If E is a lambda term $\lambda x. E $ is a lambda term
\end{enumerate}
Therefore lambda calculus is a formal system involving Abstraction and Application of functions along with some reduction rules.
Abstraction is the definition of a anonymous function , for example \\
$$ \lambda x.x^2 $$

Now Application is calling that given function by applying it.


\begin{align*}
 (\lambda x.x^2) 3\\
 3^2 \\
 9
\end{align*}
The reduction rules are :

\begin{enumerate}
    \item $\alpha$-Conversion \\
    \indent The function remains the same if all bound variable is renamed.
    In above example $\lambda y. y^2$ does the same thing.

$\lambda x.t$ is same as $ \lambda y.t[x:=y]$
    \item $\beta$-Reduction\\
     This is substitution. During application all the instances of bound variable in the expression is replaced by the argument. Again referring above example $x^2$ becomes $3^2$.\\
     $(\lambda x.E) F$ is $E[x := F]$, where $E[x := F]$
\end{enumerate}
For comprehensive treatment of this topic, see \cite{Rojas2015}. And for the original formulation by Church \cite{}
This is not sufficient for the mentioned application.




\subsubsection{Type Theory}
Type Theory is a formal system that associates every object or \textbf{term} a \textbf{Type}. The earliest version of Type Theory was introduced by Russell to avoid paradoxes in Set Theory (like \textbf{Russell's Paradox}). Later with development of Simply Typed Lambda Calculus, this became important as a foundation of Programming Languages.\\

Unlike Sets, Types do not talk about the semantics but rather the structure or syntax only. For example, in Type theory, $1+2:\mathbb{N}$ we carry out the judgement that 1+2 is a Natural Number whereas while talking bout sets $1+2 \in \mathbb{N}$  means that 1+2 is inside $\mathbb{N}$. \\With types, we do not care what 1+2 means, the information we have is the operator '+' has a type $\mathbb{N} \to \mathbb{N}$ and  $1:\mathbb{N}, 2:\mathbb{N}$ therefore the judgement  $1+2:\mathbb{N}$ follows. Whereas with sets, we proceed as $1+2=3\in \mathbb{N}$.\\

Note that verifying if a term a is of type A is decidable, i.e there is an algorithm for it. This process is called Typing or Type Checking. Proof Assistants leverage this for proof checking. Proof checking is decidable; proof finding not. \cite{Geuvers2009}\\


In simple type theory there are, 
\begin{itemize}
    \item \textbf{Base Types} : Primitive types which are not built from anything else, Eg: Boolean Type, Nat Type etc. These are generally denoted by capital letters M,N,T etc. and we can carry out the judgement as\\
        a:A, a is term of Type A.\\ 
        
    \item \textbf{Arrow Types} : Also called as function type which take input of a type and return another. As we have discussed '+' has type $\mathbb{N} \to \mathbb{N}$. More generally if a function f takes input of type A and returns output of type B then, $f:A \to B$. In logic these are equivalent to implication. We will discuss about this correspondence later.
    
\end{itemize}

This is not expressive enough for doing constructive mathematics. So the system is extended as ,

\begin{itemize}
    \item \textbf{Product Types} 
\end{itemize}



Simply Typed lambda Calculus

Dependent Type Theory 


\subsection{Curry Howard Correspondence}

% Refer 

% Make a Table  

% Show a model of a proof 
% one basic one mathy 

 \subsection{Martin Lof Type Theory }

% Finally rigidify the basics refer to the original paper 



% Update based on knowledge.....


\section{General Architecture of Proof Assistants}

\section{Upon Some Proof Assistants and Comparative Study}
\subsection{Coq}

\subsection{Lean}

\subsection{Isabelle}

\subsection{Agda}


\section{ Agda}


\section{Formalization of Some Proofs}



\section{Challenges and Workarounds}





% ======== References =========
\bibliographystyle{apalike} 
\bibliography{references.bib}

\end{document}
