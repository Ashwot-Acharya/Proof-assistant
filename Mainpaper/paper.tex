\documentclass[12pt]{article}

% ======== Packages =========
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{cite}
\usepackage{geometry}
\usepackage{bussproofs}
\usepackage{braket}
\geometry{a4paper, margin=1in}
\usepackage{titlesec}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning}
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}

\title{Working Principles of Proof Assistants and Formalization of some proofs in Agda}
\author{Bishesh Bohora, Supreme Chaudhary, Ashwot Acharya \\
\small Kathmandu University 
\small \texttt{}
}
%mention supervisor
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}

\section{Foundations}
This section sheds light upon some fundamental concept on which Proof Assistants work along with how a proof should be written so that it can be mechanically verified.
\subsection{Logic Foundations}
This works assumes prior knowledge of Propositional and Predicate Logic. And we refer to both together as \textbf{Classical}.
\subsubsection{Natural Deduction}
The propositions or formulas in Propositional Logic can be verified or proved simply by constructing their truth tables. But for logically complex propositions or propositions with many atomic statements, it becomes difficult to construct a truth table. With predicates, this becomes impossible. Therefore, to mitigate this we adhere to a basic set of inference rules with which we derive conclusions from assumptions in step by step, structured manner. The rule based system which allows us to reason about logical structure of propositions is known as \textbf{Natural Deduction}. \\
With the rules in Section 2.3 of \cite{Alrubyli2021}  we now present proofs of some propositions carried out with Natural Deduction for Classical Logic.

\newtheorem{proposition}{Proposition}[section] 
\newtheorem{example}{Example}[section]
\begin{proposition}
    \label{contra}
    \textbf{$(A \land\neg A) \to \bot $ }
  
    By negation introduction we can write $\neg A$ as $A \to \bot$

    $(A \land (A \to \bot)) \to \bot$

    \begin{prooftree}
        \AxiomC{$[A]$}
        \AxiomC{$[A \to \bot]$}
        \RightLabel{\scriptsize$\to$E}
        \BinaryInfC{$\bot$}
    \end{prooftree}
    
    

    

\end{proposition}

\begin{proposition}
    \label{lem}
    Proof for Law of Excluded Middle ($P \lor \neg P$)\\
    Note that Proposition \ref{contra} is used here.
    \begin{prooftree}
\AxiomC{$[P]$}
\RightLabel{\scriptsize$\lor$I$$}
\UnaryInfC{$P \lor \neg P$}
\AxiomC{$[\neg (P \lor \neg P)]$}
\RightLabel{\scriptsize$\bot$}
\BinaryInfC{$\bot$}
\RightLabel{\scriptsize$\neg I$}
\UnaryInfC{$\neg P$}
\RightLabel{\scriptsize$\lor$I$$}
\UnaryInfC{$P \lor \neg P$}
\AxiomC{$[\neg (P \lor \neg P)]$}
\RightLabel{\scriptsize$\bot$}
\BinaryInfC{$\bot$}
\RightLabel{\scriptsize$\neg$I$$}
\UnaryInfC{$\neg \neg (P \lor \neg P)$}
\RightLabel{\scriptsize$\neg\neg$E}
\UnaryInfC{$P \lor \neg P$}
\end{prooftree}
\end{proposition}



\begin{proposition}
    $$ \forall x (A(x) \to B(x) ) , A(s)  \vdash \exists  x B(x) $$

    \begin{prooftree}
        \AxiomC{$[ \forall x (A(x) \to B(x))]$}
        \AxiomC{$[A(s)]$}
        \RightLabel{\scriptsize $\forall E$}
        \BinaryInfC{$A(s) \to B(s)$}
        \RightLabel{\scriptsize $\to E$}
        \UnaryInfC{B(s)}
        \RightLabel{\scriptsize $\exists I$}
        \UnaryInfC{$\exists x B(x)$}
    \end{prooftree}

\end{proposition}

The \textbf{soundness} and \textbf{completeness} of this system are discussed in Section 3.1 and 3.2 \cite{Alrubyli2021}. 
\subsubsection{Intuitionstic Logic}
Intuitionstic Logic was introduced to formalize the constructive method to do mathematics. Unlike in Classical Logic a statement is True if we can construct a proof for it and to claim a statement is False, again a proof of its falsity is required. This allows the case that some statements are not provable. 
To show something exists one must provide an method or algorithm to construct it. Proof Assistants leverage this fact.
The constructive view of doing mathematics gives a stricter criteria. Intuitionstic  Logic can be obtained by restricting certain parts of Classical Logic, like the Law of Excluded Middle.

For inference rules for Natural Deduction in Intuitionstic Logic See 2.1 \cite{Pfenning2004}, here the language is slightly different from above, we have
\\
\textit{Terms} \quad $t ::= x \mid a \mid f(t_1, \ldots, t_n)$
\\
\textit{Propositions} \quad
$A ::= P(t_1, \ldots, t_n) \mid A_1 \land A_2 \mid A_1 \supset A_2 \mid A_1 \lor A_2 \mid \neg A \mid \bot \mid \top \mid \forall x. A \mid \exists x. A$

 The main focus is that this new set of rules does not contain the double negation rule which is present in what we introduced in Section 2.1.1. \textbf {Example \ref{lem}} uses the Double negation rule in its proof, which we don't have now. This agrees to that Law of Excluded Middle does not work in Intuitionstic Logic. The method of proof by contradiction also relies on this rule, so constructivists omit it.\\
These rules are revised with localized hypotheses i.e we use the above rules under a set of premises, and refer the derivation as "derived under a context". With introduction of contexts 
$$Contexts  \ \Gamma ::= .|\Gamma,u: A$$
[See 2.3 \cite{Pfenning2004}]


\subsection{$\lambda$ - Calculus and Type Theory} 

\subsubsection{ $\lambda$-Calculus}
It is a model of computation introduced by Alzano Church. It consists of construction and operations on lambda terms. 
Among the lambda terms we have,
\begin{enumerate}
    \item Variables : $x,y,z ...$ are lambda terms
    \item Application : If E,F are lambda terms EF is a lambda term 
    \item Abstraction : If E is a lambda term $\lambda x. E $ is a lambda term
\end{enumerate}
Therefore lambda calculus is a formal system involving Abstraction and Application of functions along with some reduction rules.
Abstraction is the definition of a anonymous function , for example \\
$$ \lambda x.x^2 $$

Now Application is calling that given function by applying it.

\begin{example}
\begin{align*}
 (\lambda x.x^2) 3\\
 3^2 \\
 9
\end{align*}
\end{example}
The functions can be constructed such that they can take multiple values too, say a function to compute sum of squares can be implemented with lambda calculus as

\begin{example}
    $$\lambda x \lambda y. x^2 +y^2$$
Its application is as 
$$(\lambda x \lambda y. x^2 +y^2) (3) (4)$$
$$(\lambda y. 3^2 + y^2)(4)$$
$$3^2+4^2$$
$$9+16$$
$$25$$
\end{example}

This is called \textbf{currying}.\\
The reduction rules are :

\begin{enumerate}
    \item $\alpha$-Conversion \\
    \indent The function remains the same if all bound variable is renamed.
    In above example $\lambda y. y^2$ does the same thing.

$\lambda x.t$ is same as $ \lambda y.t[x:=y]$
    \item $\beta$-Reduction\\
     This is substitution. During application all the instances of bound variable in the expression is replaced by the argument. Again referring above example $x^2$ becomes $3^2$.\\
     $(\lambda x.E) F$ is $E[x := F]$, where $E[x := F]$
\end{enumerate}
For comprehensive treatment of this topic, see \cite{Rojas2015}. And for the original formulation by Church \cite{}





\subsubsection{Type Theory}
Type Theory is a formal system that associates every object or \textbf{term} a \textbf{Type}. The earliest version of Type Theory was introduced by Russell to avoid paradoxes in Set Theory (like \textbf{Russell's Paradox}). Later with development of Simply Typed Lambda Calculus, this became important as a foundation of Programming Languages.\\

Unlike Sets, Types do not talk about the semantics but rather the structure or syntax only. For example, in Type theory, $1+2:\mathbb{N}$ we carry out the judgement that 1+2 is a Natural Number whereas while talking bout sets $1+2 \in \mathbb{N}$  means that 1+2 is inside $\mathbb{N}$. \\With types, we do not care what 1+2 means, the information we have is the operator '+' has a type $\mathbb{N} \times \mathbb{N}  \to \mathbb{N}$ and  $1:\mathbb{N}, 2:\mathbb{N}$ therefore the judgement  $1+2:\mathbb{N}$ follows. Whereas with sets, we proceed as $1+2=3\in \mathbb{N}$.\\

Note that verifying if a term a is of type A is decidable, i.e there is an algorithm for it. This process is called Typing or Type Checking. Proof Assistants leverage this for proof checking. Proof checking is decidable; proof finding not. \cite{Geuvers2009}\\


In simple type theory there are, 
\begin{itemize}
    \item \textbf{Base Types} : Primitive types which are not built from anything else, Eg: Boolean Type, Nat Type, $\bot$ or Empty Type etc. These are generally denoted by capital letters M,N,T etc. and we can carry out the judgement as\\
        a:A, a is term of Type A.\\ 
        
    \item \textbf{Arrow Types} : Also called as function type which take input of a type and return another. As we have discussed '+' has type $\mathbb{N} \to \mathbb{N}$. More generally if a function f takes input of type A and returns output of type B then, $f:A \to B$. In logic these are equivalent to implication. We will discuss about this correspondence later.
    
\end{itemize}

Which can be further extended as,
\begin{itemize}
    \item \textbf{Product Types} Product types are similar to Cartesian Products from Set Theory, the terms inhabiting the product type is a pair of terms from the involving types, $a:A, b:B $ then $ \left\langle a,b \right\rangle : A \times B$ .
    \item \textbf{Sum Type} This is similar to disjoint union with sets, therefore the term has one of the participating types. 
     $$a:A, b:B, a:A+B, b:A+B$$

    
\end{itemize}
\subsubsection{Simply Typed Lambda Calculus}
 We have already discussed about the Lambda Calculus as well as Types, now we assign a type to each lambda term. The functions in Untyped lambda Calculus are too general. In Example 2.5 we did not mention what squaring means, can we apply it to some arbitary type of data, what will the function return, these concerns remain unanswered. But when we assign every term a type, it can be assigned what can the function take and return.
 \begin{itemize}
    \item Variables  x:T , a variable which has a type T
    \item Abstraction $\lambda x:M.t:T$ , the function takes an input of type M and returns t of type T.
    \item Application $(\lambda x:M.t:T)(a:M)$
    


 \end{itemize}
 
 We present a typed version of Example 2.5\\
 \begin{example}
    $$\lambda x:\mathbb{N}.x^2:\mathbb{N}$$
    Note that now this function can only take natural numbers,\\
    Application
    $$(\lambda x:\mathbb{N}.x^2:\mathbb{N})(3)$$
    which gives, along with the judgement
    $$3^2:\mathbb{N}$$
 \end{example}

\subsubsection{Dependent Type Theory and Dependently Typed $\lambda$-Calculus}
In this extension of theory of types, we allow types to depend upon some value. For example, modeling vectors with types, we require it to depend on Natural number for its dimension. 
u:Vec(n) means u is a vector type with n dimension and n:$\mathbb{N}$. 
This can be taken as a function type with $Vec:\mathbb{N} \to Type$ , which takes a type of natural number as input and returns a type. This allows indexing of types and is useful for representing predicates.
And similarly as with simply typed $\lambda$-Calculus we can have lambda terms with dependent types. 

\subsection{Proof Terms and The Curry Howard Correspondence}
    Let us treat every proposition or Logical Formula as a Type, and their proofs as the term inhabiting it. Intuitionstically, we interpret a proposition being true if we present a proof for it. Here, it will be true if there is a term (proof) inhabiting the type (proposition).
    p:P is now interpreted as p is a proof of P. In \cite{How} the strong correspondence between intuitionstic derivation and lambda terms was mentioned. In essence the corrrespondence is as follows,
    \begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Logic}                & \textbf{Computation}         & \textbf{Type Theory}             \\ \hline
Proposition                  & Type                         & Type                             \\ \hline
Proof                        & Program                      & Term                             \\ \hline
Proof Normalization          & Program Evaluation           & Reduction                        \\ \hline
Implication ($A \rightarrow B$) & Function Type ($A \to B$)    & $\lambda$-abstraction            \\ \hline
Conjunction ($A \land B$)    & Product Type ($A \times B$)  & Pairing                          \\ \hline
Disjunction ($A \lor B$)     & Sum Type ($A + B$)           & Tagged union                     \\ \hline
Falsehood ($\bot$)           & Empty Type                   & No term                          \\ \hline
Truth ($\top$)               & Unit Type                    & Singleton term                   \\ \hline
Negation ($\neg A$)          & $A \to \bot$                 & Function to empty type           \\ \hline
Universal Quantifier ($\forall x. A(x)$) & Dependent Product ($\Pi x : A. B(x)$) & Function over types \\ \hline
Existential Quantifier ($\exists x. A(x)$) & Dependent Sum ($\Sigma x : A. B(x)$) & Pair with dependent type \\ \hline


\end{tabular}
\caption{Curry–Howard Correspondence: Logic, Computation, and Type Theory}
\end{table}\\
The use of dependent product and sum for the Quantifier highlights the necessity of Dependent Type Theory. The rules  (Proof Terms only), equivalent to Deduction rules of Intuitionstic Logic are in Section 2.4 of \cite{Pfenning2004}. Note that this does not contain the rule for predicates. While writing a proof in a proof assistant our reasoning follows deduction rules of this kind. 
Then to write a  program (equivalent to proof) of the proposition $A \to B \to A$, we need to construct a function that takes term of type A , term of type B and returns term of type A, that is $\lambda a{:}A.\lambda b{:}B.t{:}A $ which proceeds as

   \begin{prooftree}
  \AxiomC{}
  \RightLabel{\scriptsize var}
  \UnaryInfC{$a{:}A,\ b{:}B \vdash a : A$}
  \RightLabel{\scriptsize lam}
  \UnaryInfC{$a{:}A \vdash \lambda b{:}B.\ a : B \rightarrow A$}
  \RightLabel{\scriptsize lam}
  \UnaryInfC{$\vdash \lambda a{:}A.\lambda b{:}B.\ a : A \rightarrow B \rightarrow A$}
\end{prooftree}



 \subsection{Martin-Löf Type Theory }
    Martin-Löf Type Theory is the formal logic system that was developed to support constructive mathematics. It's often referred to as Intuitionstic Type Theory. It carries the use of dependent types and is the backbone of Proof Assistants.\\
        The following types are also valid in this system.
        \begin{itemize}
            \item $\prod$-Type : The dependent function type, as mentioned in Table 1. it supports the interpretation of Universal Quantifier.
            \item $\sum$-Type : The dependent sum type, equivalent to the Existential Quantifier.
            \item Identity Type : Equality itself is internalized as a type in this system. Hence, we can judge if two terms are the same. By the correspondence, proofs are terms then this allows proof assistants to match proofs and declare their Equality.
            
        \end{itemize}
        Furthermore, We also have \textbf{Type Universes}, Every Type itself can be assigned a Type. This creates a hierarchy of types. For example, $1:\mathbb{N},\mathbb{N}:Type:...$, The number 1 has type Natural, then Natural has a type called Type, which itself can have another type. Not to be interpreted as , a set being contained in another set, this gives rise to paradoxes. But rather take it as hierarchy of Universes. From this we can talk about Types themselves within our system, and  allow proof assistants to safely handle abstraction over types.\\
        The results from  \cite{martinlof1972intuitionistic_theory} where this system was first introduced by Martin Löf, will be mentioned as necessary.
        
        





% Finally rigidify the basics refer to the original paper 



% Update based on knowledge.....


\section{General Architecture of Proof Assistants}

\section{Upon Some Proof Assistants and Comparative Study}
\subsection{Coq}

\subsection{Lean}

\subsection{Isabelle}

\subsection{Agda}


\section{ Agda}


\section{Formalization of Some Proofs}



\section{Challenges and Workarounds}





% ======== References =========
\bibliographystyle{apalike} 
\bibliography{references.bib}

\end{document}
