\documentclass[aspectratio=169, 12pt]{beamer}

\usepackage[english]{babel}                 %%%%%%%%%%%%%%%%%% (EDIT LANGUAGE)

\usepackage{Custom}                         %%%%%%%%%%%%%%%%%%    (EDIT NAMES)
\usepackage{Custom-2}                         %%%%%%%%%%%%%%%%%%    (EDIT COLOURS)
\usepackage{AuxiliaryFiles/AuxiliaryFiles}  %%%%%%%%%%%%%    (DO NOT EDIT)
\usepackage{graphics}
\begin{document}
\TitlePage        
\SectionPage    
\SubsectionPage    %%%% PAGE AT THE BEGINNIN OF A SECTION - IF NOT NEEDED, COMMENT IT
\ProgressBar       %%%% PROGRESS BAR ON THE RIGHT MARGIN - IF NOT NEEDED, COMMENT IT
\PageNumbering     %%%% SLIDES NUMBERING - IF NOT NEEDED, COMMENT IT


\input{AuxiliaryFiles/SettingBackup}     

\section{Proof Assistants} 
\subsection*{What are proof assistant}
\begin{frame}{What are proof assistant}
    Proof assistant, are software more specifically a type of programming language thats allows us to 
    formalize mathematical proofs in computer for digital verification. 
\end{frame}
\subsection*{Why digital verification is needed?}
\begin{frame}{Need of digital verification}
    \begin{itemize}
        \item Fast and Efficient 
        \item Many cases can be explored which would take mathematicians  long time \\
           \indent  \footnotesize ex:   The Kepler Conjecture's proof , which was so complex that verifying it manually would take 20 person-years, but proof assistants made this verification feasible and fast. 
    
        \item What if you don't use proof assistants? ABC conjecture
    \end{itemize}

\end{frame}


\begin{frame}
    \begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{pa.jpeg}
\end{figure}
\end{frame}

\section{Foundations}

\begin{frame}{Natural Deduction}
\begin{itemize}
    \item \textbf{Natural Deduction} is a rule-based system for deriving conclusions from assumptions in logic.
    \item Instead of using exhaustive truth tables, proofs are built step-by-step using inference rules.
    \item Example: Proving from $A \land (A \rightarrow \bot)$ that $\bot$ (contradiction) can be derived.
\end{itemize}
\end{frame}
\begin{frame}
    \begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{nd.jpeg}
\end{figure}
\end{frame}

\begin{frame}{Intuitionistic Logic}
\begin{itemize}
    \item \textbf{Intuitionistic Logic} Also called Constructive Logic, reflects principles of constructive mathematics, where a statement is only true if a proof can be constructed.
    \item Omits some classical logic rules, such as the Law of Excluded Middle.
    \item Stronger requirement: to prove existence, a method or algorithm must be given.
    \item Proof assistants leverage this constructive approach for digital verification.
\end{itemize}
\end{frame}
 

\begin{frame}
    \begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{nid.jpeg}

\end{figure}
Inference Rules for Intuitionistic Logic
\end{frame}
\begin{frame}{Lambda Calculus}
\textbf{What is Lambda Calculus?}
\begin{itemize}
  \item A formal model of computation by Alonzo Church
  \item Lambda Terms:
    \begin{itemize}
        \item Variables: $x$, $y$, $z$
        \item Abstraction: $\lambda x.E$
        \item Application: $(\lambda x.E)F$
    \end{itemize}
\end{itemize}
\end{frame}
\begin{frame}
\textbf{Examples}
\begin{itemize}
    \item $\lambda x.x^2$ is a function
    \item $(\lambda x.x^2)(3) \rightarrow 9$
\end{itemize}

\end{frame}

\begin{frame}{Type Theory \& Simply Typed Lambda Calculus}
\textbf{Type Theory Basics}
\begin{itemize}
  \item Assigns types to terms: $1 : \mathbb{N}$, $+ : \mathbb{N} \times \mathbb{N} \to \mathbb{N}$
  \item Typing is decidable
\end{itemize}

\textbf{Type Categories}
\begin{itemize}
  \item Base Types: $\mathbb{N}$, Bool, $\bot$
  \item Arrow Types: $f : A \to B$
  \item Product Types: $\langle a, b \rangle : A \times B$
  \item Sum Types: $a : A + B$
\end{itemize}
\end{frame}
\begin{frame}
   \textbf{Typed Lambda Calculus}
\begin{itemize}
  \item $(\lambda x : \mathbb{N}.x^2) : \mathbb{N} \to \mathbb{N}$
\end{itemize}
 \textbf{Dependent Types}
\begin{itemize}
  \item Types depend on values: $Vec(n)$
  \item Indexed types, predicate representation
  \item $Vec : \mathbb{N} \to Type$
\end{itemize}

\end{frame}


\begin{frame}{ Curry–Howard Correspondence}
    \begin{itemize}
  \item sometimes referred as Curry Howard Isomorphism
  \item A connection between logic, computation, and type theory
  \item Also known as the \textit{proofs-as-programs} and \textit{propositions-as-types} principle
\end{itemize}

\textbf{Core Idea}
\begin{itemize}
  \item A \textbf{proposition} corresponds to a \textbf{type}
  \item A \textbf{proof} of the proposition is a \textbf{program} (term) of that type
  \item Proof checking is equivalent to type checking
  \item Proof normalization corresponds to program evaluation
\end{itemize}
\end{frame}

\begin{frame}
\textbf{Curry–Howard Correspondence}
\begin{tabular}{|c|c|c|}
\hline
Logic & Type Theory & Programming \\
\hline
Proposition & Type & - \\
Proof & Term & Program \\
Implication $A \to B$ & $A \to B$ & $\lambda$-abstraction \\
Conjunction $A \land B$ & $A \times B$ & Pair \\
Disjunction $A \lor B$ & $A + B$ & Tagged union \\
Falsehood $\bot$ & Empty Type & No term \\
Universal $\forall x.A(x)$ & $\Pi x:A.B(x)$ & Function over types \\
Existential $\exists x.A(x)$ & $\Sigma x:A.B(x)$ & Dependent pair \\
\hline
\end{tabular}

\end{frame}

    \begin{frame}{Martin-Löf Type Theory}
\textbf{What is it?}
\begin{itemize}
  \item A formal system for constructive mathematics
  \item Also known as Intuitionistic Type Theory
  \item Backbone of modern Proof Assistants
\end{itemize}

\textbf{Core Types}
\begin{itemize}
  \item \textbf{} ($\Pi$-type): Dependent function type, $\forall x:A.B(x)$
  \item \textbf{} ($\Sigma$-type): Dependent sum type, $\exists x:A.B(x)$
  \item \textbf{Identity Type}: Internal equality between terms
\end{itemize}

\end{frame}

\begin{frame}
  \textbf{Type Universes}
\begin{itemize}
  \item Types have types: $1 : \mathbb{N}, \mathbb{N} : Type, Type : \cdots$
  \item Not like sets within sets — avoids paradoxes
  \item Enables reasoning and abstraction over types themselves
  
\end{itemize}  
\end{frame}


\section{Architecture of proof assistant}
\begin{frame}{Architecture of a Proof Assistant}
\begin{itemize}
    \item \textbf{Kernel}: Minimal, trustworthy codebase enforcing logical rules and validating proofs.
    \item \textbf{Tactic Engine}: Helps build and automate proofs step by step.
    \item \textbf{Formal Proof Language}: Rigorously expresses definitions, statements, and proofs.
    \item \textbf{Libraries}: Collections of verified mathematical foundations for reuse.
    \item \textbf{User Interface}: IDEs and plugins for interactive, efficient proof development.
\end{itemize}
\end{frame}
\subsection*{Kernel}
\begin{frame}{Kernel: The Trusted Core}
\begin{itemize}
    \item The \textbf{kernel} is the minimal and most critical part of a proof assistant.
    \item It enforces the logical rules of the underlying formal system (e.g., type theory).
    \item Responsible for \textbf{validating every proof step} to guarantee correctness.
    \item Ensures \textbf{soundness and trustworthiness}; the rest of the system depends on its integrity.
    \item Typically very small and rigorously tested or formally verified to avoid bugs.
    \item Example: Agda’s kernel is written in Haskell and integrates normalization to check definitional equality.
\end{itemize}
\end{frame}
\subsection*{Tactic Engine}

\begin{frame}{Tactic Engine: Proof Construction Assistant}
\begin{itemize}
    \item The \textbf{tactic engine} supports users in constructing proofs interactively.
    \item It breaks complex proof goals into simpler subgoals using \textbf{proof strategies} called tactics.
    \item Provides \textbf{automation} for common proof patterns, speeding up proof development.
    \item Enables both \textbf{forward} and \textbf{backward} reasoning approaches.
    \item Even fully automated tactics rely on the kernel for final verification.
    \item Varies among assistants (Agda has minimal/no tactics, Coq and Lean have powerful tactic systems).
\end{itemize}
\end{frame}
\subsection*{ Language}

\begin{frame}{Formal Proof Language: Expressing Proofs Precisely}
\begin{itemize}
    \item This language allows expressing \textbf{definitions, propositions, and proofs} rigorously.
    \item Typically a \textbf{dependently typed language} so logical properties can be encoded as types.
    \item Provides \textbf{syntax and semantics} suitable for formal reasoning and machine checking.
    \item Enables users to write \textbf{human-readable yet unambiguous} formal proofs.
    \item Integrates smoothly with tactics and type checker to maintain correctness.
    \item Example languages: Agda’s core language, Coq’s Gallina, Lean’s dependent type language.
\end{itemize}
\end{frame}
\subsection*{Libraries}
\begin{frame}{Libraries: Reusable Verified Foundations}
\begin{itemize}
    \item Extensive collections of \textbf{formalized mathematics and algorithms} supporting new developments.
    \item Include \textbf{basic theories} such as arithmetic, algebra, logic, and set theory.
    \item Enable users to \textbf{build on existing verified results} without re-proving foundations.
    \item Libraries evolve and grow, fostering \textbf{collaboration and community sharing}.
    \item Well-maintained libraries reduce duplication and improve proof assistant adoption.
    \item Examples include Coq’s Standard Library, Agda Standard Library, Lean’s mathlib.
\end{itemize}
\end{frame}
\subsection*{User Interface}
\begin{frame}{User Interface: Proof Development Environment}
\begin{itemize}
    \item Provides \textbf{interactive tools} like IDEs, editor plugins, or command line interfaces.
    \item Features include \textbf{syntax highlighting, error reporting, real-time proof state visualization,} and \textbf{auto-completion}.
    \item Enhances \textbf{usability and productivity} for proof authors.
    \item Supports \textbf{integration with tactics and proof language} for seamless workflow.
    \item Examples: CoqIDE, Proof General, Emacs-mode for Agda, VS Code extensions.
    \item A good interface lowers the learning curve and makes formalization more accessible.
\end{itemize}
\end{frame}
\section{Comparative Study}
\begin{frame}{Comparative Table: Agda, Rocq (Coq), and Lean}
  
\begin{table}
\centering
\scalebox{0.75}{
    \begin{tabular}{|p{2cm}|p{4cm}|p{4cm}|p{4cm}|}
    \hline
    \small \textbf{Component} &  \small \textbf{Agda} & \small \textbf{Rocq (Coq)} & \small \textbf{Lean} \\
    \toprule
    \small \textbf{Proof Style} & \footnotesize Explicit term-based, manual proof writing & \footnotesize Tactic-based, automated backward reasoning & \footnotesize Both tactic-based and term-style \\

    \small \textbf{Kernel} & Minimal, written in Haskell, tight integration with normalization & Based on Calculus of Inductive Constructions (CIC), written in Coq (extracted to OCaml) & CIC-based, written in C++/C \\
    \small \textbf{Type Checking} & Bidirectional, transparent, normalization by evaluation & Bidirectional, heavy conversion, strong automation & Bidirectional, smart elaboration (coercion, backtracking, overloading) \\

    \small \textbf{Automation} & Limited (no tactics, minimal automation) & Extensive tactic engine and proof search & Advanced, seamless tactic/term mixing, smart elaborator \\

    \small \textbf{Use Cases} & Foundations, education, dependently typed programming & Large/complex formalizations, industrial-scale proofs & Research, education, combinatorial/mathematical formalizations \\
    \bottomrule
    \end{tabular}
}
\end{table}
\end{frame}

\section{Formalization Of Some proofs}
\subsection*{Defining Natural Numbers} 
    \begin{frame}[fragile]
        \frametitle{Eg: Defining Natural Numbers}
        \begin{verbatim}
           data N : Set where 
                Zero : N 
                suc : N -> N
        \end{verbatim}
    \end{frame}


\input{AuxiliaryFiles/Thanks}  
\end{document}