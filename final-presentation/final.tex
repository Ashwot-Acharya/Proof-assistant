\documentclass[aspectratio=169, 12pt]{beamer}

\usepackage[english]{babel}                 %%%%%%%%%%%%%%%%%% (EDIT LANGUAGE)

\usepackage{Custom}                         %%%%%%%%%%%%%%%%%%    (EDIT NAMES)
\usepackage{Custom-2}                         %%%%%%%%%%%%%%%%%%    (EDIT COLOURS)
\usepackage{AuxiliaryFiles/AuxiliaryFiles}  %%%%%%%%%%%%%    (DO NOT EDIT)
\usepackage{graphics}

\DeclareUnicodeCharacter{2200}{\ensuremath{\forall}}    % ∀
\DeclareUnicodeCharacter{2113}{\ensuremath{\ell}}       % ℓ
\DeclareUnicodeCharacter{2192}{\ensuremath{\rightarrow}}% →
\DeclareUnicodeCharacter{00D7}{\ensuremath{\times}}     % ×
\DeclareUnicodeCharacter{228E}{\ensuremath{\uplus}}   % ⊎
\DeclareUnicodeCharacter{22A5}{\ensuremath{\bot}}       % ⊥
\DeclareUnicodeCharacter{00AC}{\ensuremath{\neg}}       % ¬
\DeclareUnicodeCharacter{2081}{\textsubscript{1}}       % ₁
\DeclareUnicodeCharacter{2082}{\textsubscript{2}}       % ₂
\DeclareUnicodeCharacter{03BB}{\ensuremath{\lambda}}    % λ
\DeclareUnicodeCharacter{03A3}{\ensuremath{\Sigma}}   % Σ
\DeclareUnicodeCharacter{211A}{\ensuremath{\mathbb{Q}}} % ℚ
\DeclareUnicodeCharacter{2223}{\ensuremath{\mid}}       % ∣
\DeclareUnicodeCharacter{2264}{\ensuremath{\leq}}       % ≤
\DeclareUnicodeCharacter{2261}{\ensuremath{\equiv}}     % ≡
\DeclareUnicodeCharacter{21D2}{\ensuremath{\Rightarrow}}% ⇒
\DeclareUnicodeCharacter{2243}{\ensuremath{\simeq}}     % ≃
\DeclareUnicodeCharacter{2124}{\ensuremath{\mathbb{Z}}} % ℤ
\DeclareUnicodeCharacter{2115}{\ensuremath{\mathbb{N}}} % ℕ
\DeclareUnicodeCharacter{211D}{\ensuremath{\mathbb{R}}} % ℝ
\begin{document}
\TitlePage        
\SectionPage    
\SubsectionPage    %%%% PAGE AT THE BEGINNIN OF A SECTION - IF NOT NEEDED, COMMENT IT
\ProgressBar       %%%% PROGRESS BAR ON THE RIGHT MARGIN - IF NOT NEEDED, COMMENT IT
\PageNumbering     %%%% SLIDES NUMBERING - IF NOT NEEDED, COMMENT IT


\input{AuxiliaryFiles/SettingBackup}     

\section{Proof Assistants} 
\subsection*{What are proof assistant}
\begin{frame}{What are proof assistant}
    Proof assistant, are software more specifically a type of programming language thats allows us to 
    formalize mathematical proofs in computer for digital verification. 
\end{frame}
\subsection*{Why digital verification is needed?}
\begin{frame}{Need of digital verification}
    \begin{itemize}
        \item Fast and Efficient 
        \item Many cases can be explored which would take mathematicians  long time \\
           \indent  \footnotesize ex:   The Kepler Conjecture's proof , which was so complex that verifying it manually would take 20 person-years, but proof assistants made this verification feasible and fast. 
    
        \item What if you don't use proof assistants? ABC conjecture
    \end{itemize}

\end{frame}


\begin{frame}
    \begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{pa.jpeg}
\end{figure}
\end{frame}

\section{Foundations}

\subsection*{Naturl deduction}
\begin{frame}{Natural Deduction}
\begin{itemize}
    \item \textbf{Natural Deduction} is a rule-based system for deriving conclusions from assumptions in logic.
    \item Instead of using exhaustive truth tables, proofs are built step-by-step using inference rules.
    \item Example: Proving from $A \land (A \rightarrow \bot)$ that $\bot$ (contradiction) can be derived.
    \item Basis for how proof assistants check the logical structure of proofs.
\end{itemize}
\end{frame}
\begin{frame}
    \begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{nd.jpeg}
\end{figure}
\end{frame}

\subsection*{Ins}
\begin{frame}{Intuitionistic Logic}
\begin{itemize}
    \item \textbf{Intuitionistic Logic} Also called Constructive Logic, reflects principles of constructive mathematics, where a statement is only true if a proof can be constructed.
    \item Omits some classical logic rules, such as the Law of Excluded Middle.
    \item Stronger requirement: to prove existence, a method or algorithm must be given.
    \item Proof assistants leverage this constructive approach for digital verification.
\end{itemize}
\end{frame}
 

\begin{frame}
    \begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{nid.jpeg}

\end{figure}
Inference Rules for Intuitionistic Logic
\end{frame}
\subsection*{$\lambda$-Calculus}
\begin{frame}{$\lambda$-Calculus and Type Theory}
\begin{itemize}
    \item \textbf{$\lambda$-Calculus}: A foundational system for defining and applying functions using abstraction and application.
    \item \textbf{Type Theory}: Assigns types to every term; ensures correctness of operations.
         \item \emph{Dependent types} allow types to depend on values, expressing complex logical properties.

    \item \textbf{Curry--Howard Correspondence}: 
    \begin{itemize}
        \item Propositions $\leftrightarrow$ Types
        \item Proofs $\leftrightarrow$ Programs
    \end{itemize}
    \item \emph{Dependent types} allow types to depend on values, expressing complex logical properties.
\end{itemize}
\end{frame}
\section{Architecture of proof assistant}
\begin{frame}{Architecture of a Proof Assistant}
\begin{itemize}
    \item \textbf{Kernel}: Minimal, trustworthy codebase enforcing logical rules and validating proofs.
    \item \textbf{Tactic Engine}: Helps build and automate proofs step by step.
    \item \textbf{Formal Proof Language}: Rigorously expresses definitions, statements, and proofs.
    \item \textbf{Libraries}: Collections of verified mathematical foundations for reuse.
    \item \textbf{User Interface}: IDEs and plugins for interactive, efficient proof development.
\end{itemize}
\end{frame}
\subsection*{Kernel}
\begin{frame}{Kernel: The Trusted Core}
\begin{itemize}
    \item The \textbf{kernel} is the minimal and most critical part of a proof assistant.
    \item It enforces the logical rules of the underlying formal system (e.g., type theory).
    \item Responsible for \textbf{validating every proof step} to guarantee correctness.
    \item Ensures \textbf{soundness and trustworthiness}; the rest of the system depends on its integrity.
    \item Typically very small and rigorously tested or formally verified to avoid bugs.
    \item Example: Agda’s kernel is written in Haskell and integrates normalization to check definitional equality.
\end{itemize}
\end{frame}
\subsection*{Tactic Engine}

\begin{frame}{Tactic Engine: Proof Construction Assistant}
\begin{itemize}
    \item The \textbf{tactic engine} supports users in constructing proofs interactively.
    \item It breaks complex proof goals into simpler subgoals using \textbf{proof strategies} called tactics.
    \item Provides \textbf{automation} for common proof patterns, speeding up proof development.
    \item Enables both \textbf{forward} and \textbf{backward} reasoning approaches.
    \item Even fully automated tactics rely on the kernel for final verification.
    \item Varies among assistants (Agda has minimal/no tactics, Coq and Lean have powerful tactic systems).
\end{itemize}
\end{frame}
\subsection*{ Language}

\begin{frame}{Formal Proof Language: Expressing Proofs Precisely}
\begin{itemize}
    \item This language allows expressing \textbf{definitions, propositions, and proofs} rigorously.
    \item Typically a \textbf{dependently typed language} so logical properties can be encoded as types.
    \item Provides \textbf{syntax and semantics} suitable for formal reasoning and machine checking.
    \item Enables users to write \textbf{human-readable yet unambiguous} formal proofs.
    \item Integrates smoothly with tactics and type checker to maintain correctness.
    \item Example languages: Agda’s core language, Coq’s Gallina, Lean’s dependent type language.
\end{itemize}
\end{frame}
\subsection*{Libraries}
\begin{frame}{Libraries: Reusable Verified Foundations}
\begin{itemize}
    \item Extensive collections of \textbf{formalized mathematics and algorithms} supporting new developments.
    \item Include \textbf{basic theories} such as arithmetic, algebra, logic, and set theory.
    \item Enable users to \textbf{build on existing verified results} without re-proving foundations.
    \item Libraries evolve and grow, fostering \textbf{collaboration and community sharing}.
    \item Well-maintained libraries reduce duplication and improve proof assistant adoption.
    \item Examples include Coq’s Standard Library, Agda Standard Library, Lean’s mathlib.
\end{itemize}
\end{frame}
\subsection*{User Interface}
\begin{frame}{User Interface: Proof Development Environment}
\begin{itemize}
    \item Provides \textbf{interactive tools} like IDEs, editor plugins, or command line interfaces.
    \item Features include \textbf{syntax highlighting, error reporting, real-time proof state visualization,} and \textbf{auto-completion}.
    \item Enhances \textbf{usability and productivity} for proof authors.
    \item Supports \textbf{integration with tactics and proof language} for seamless workflow.
    \item Examples: CoqIDE, Proof General, Emacs-mode for Agda, VS Code extensions.
    \item A good interface lowers the learning curve and makes formalization more accessible.
\end{itemize}
\end{frame}
\section{Comparative Study}
\begin{frame}{Comparative Table: Agda, Rocq (Coq), and Lean}
  
\begin{table}
\centering
\scalebox{0.75}{
    \begin{tabular}{|p{2cm}|p{4cm}|p{4cm}|p{4cm}|}
    \hline
    \small \textbf{Component} &  \small \textbf{Agda} & \small \textbf{Rocq (Coq)} & \small \textbf{Lean} \\
    \toprule
    \small \textbf{Proof Style} & \footnotesize Explicit term-based, manual proof writing & \footnotesize Tactic-based, automated backward reasoning & \footnotesize Both tactic-based and term-style \\

    \small \textbf{Kernel} & Minimal, written in Haskell, tight integration with normalization & Based on Calculus of Inductive Constructions (CIC), written in Coq (extracted to OCaml) & CIC-based, written in C++/C \\
    \small \textbf{Type Checking} & Bidirectional, transparent, normalization by evaluation & Bidirectional, heavy conversion, strong automation & Bidirectional, smart elaboration (coercion, backtracking, overloading) \\

    \small \textbf{Automation} & Limited (no tactics, minimal automation) & Extensive tactic engine and proof search & Advanced, seamless tactic/term mixing, smart elaborator \\

    \small \textbf{Use Cases} & Foundations, education, dependently typed programming & Large/complex formalizations, industrial-scale proofs & Research, education, combinatorial/mathematical formalizations \\
    \bottomrule
    \end{tabular}
}
\end{table}
\end{frame}

\section{Formalization Of Some Proofs}
\subsection*{Defining Natural Numbers} 
    \begin{frame}[fragile]
        \frametitle{Eg: Defining Natural Numbers}
        \begin{verbatim}
           data N : Set where 
                Zero : N 
                suc : N -> N
        \end{verbatim}
    \end{frame}
\subsection*{simple properities  } 
\begin{frame}[fragile]
    \frametitle{Eg: Some mathematical properities }
    \begin{verbatim}
        Transitivity properties: 

        data _==_ { A : Set } ( x : A ) : A -> Set where
            refl : x == x

        trans : { A : Set } { x y z : A}
            -> x == y
            -> y == z
            -> x == z
            trans refl refl = refl
    \end{verbatim}
\end{frame}
\subsection{Formalization Of DeMorgan's Law} 
\begin{frame}[fragile]
    \frametitle{DeMorgan's Law in agda}
   \footnotesize \begin{verbatim}
DeMorgan’s Law
open import Agda.Primitive using (Level; lzero)
open import Data.Product using (_×_; _,_)
open import Data.Sum using (_⊎_; inj1; inj2)
open import Relation.Nullary using (Dec; yes; no)
open import Data.Empty using (⊥; ⊥-elim)
open import Relation.Nullary.Negation using (¬_)
--One Direction
deMorganOneWay : ∀ {ℓ} {P Q : Set ℓ} → (¬ P) ⊎ (¬ Q) → ¬ (P × Q)
deMorganOneWay (inj1 np) (p , q) = np p
deMorganOneWay (inj2 nq) (p , q) = nq q

    \end{verbatim}
    
\end{frame}
\begin{frame}[fragile]

    \small \begin{verbatim}
Converse, Requires Non Constructive Assumptions
deMorganOtherWay :
∀ {ℓ} {P Q : Set ℓ}
→ Dec P
→ Dec Q
→ ¬ (P × Q)
→ (¬ P) ⊎ (¬ Q)
deMorganOtherWay (yes p) _ notPQ = inj2 (λ q → notPQ (p , q))
deMorganOtherWay (no np) (yes q) _ = inj1 np
deMorganOtherWay (no np) (no nq) _ = inj1 np -- or inj2 nq
    \end{verbatim}
    
\end{frame}
\section{Limitations}
\begin{frame}{Limitations}
    \begin{itemize}
        \item Unable to completely formalize " Constructive Reals" 
        \item issue encountered while creating a reciprocal function N → Q  
        \item Limited time to explore the rigorous algorithm of bi-directional type checking
     
    \end{itemize}
\end{frame} 


\input{AuxiliaryFiles/Thanks}  
\end{document}