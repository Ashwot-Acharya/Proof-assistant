\documentclass[aspectratio=169, 12pt]{beamer}

\usepackage[english]{babel}                 %%%%%%%%%%%%%%%%%% (EDIT LANGUAGE)

\usepackage{Custom}                         %%%%%%%%%%%%%%%%%%    (EDIT NAMES)
\usepackage{Custom-2}                         %%%%%%%%%%%%%%%%%%    (EDIT COLOURS)
\usepackage{AuxiliaryFiles/AuxiliaryFiles}  %%%%%%%%%%%%%    (DO NOT EDIT)
\usepackage{graphics}
\begin{document}
\TitlePage        
\SectionPage    
\SubsectionPage    %%%% PAGE AT THE BEGINNIN OF A SECTION - IF NOT NEEDED, COMMENT IT
\ProgressBar       %%%% PROGRESS BAR ON THE RIGHT MARGIN - IF NOT NEEDED, COMMENT IT
\PageNumbering     %%%% SLIDES NUMBERING - IF NOT NEEDED, COMMENT IT


\input{AuxiliaryFiles/SettingBackup}     

\section{Proof Assistants} 
\subsection*{What are proof assistant}
\begin{frame}{What are proof assistant}
    Proof assistant, are software more specifically a type of programming language thats allows us to 
    formalize mathematical proofs in computer for digital verification. 
\end{frame}
\subsection*{Why digital verification is needed?}
\begin{frame}{Need of digital verification}
    \begin{itemize}
        \item Fast and Efficient 
        \item Many cases can be explored which would take mathematicians  long time \\
           \indent  \footnotesize ex:   The Kepler Conjecture's proof , which was so complex that verifying it manually would take 20 person-years, but proof assistants made this verification feasible and fast. 
    
        \item What if you don't use proof assistants? ABC conjecture
    \end{itemize}

\end{frame}


\begin{frame}
    \begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{pa.jpeg}
\end{figure}
\end{frame}

\section{Foundations}

\subsection*{Naturl deduction}
\begin{frame}{Natural Deduction}
\begin{itemize}
    \item \textbf{Natural Deduction} is a rule-based system for deriving conclusions from assumptions in logic.
    \item Instead of using exhaustive truth tables, proofs are built step-by-step using inference rules.
    \item Example: Proving from $A \land (A \rightarrow \bot)$ that $\bot$ (contradiction) can be derived.
    \item Basis for how proof assistants check the logical structure of proofs.
\end{itemize}
\end{frame}
\begin{frame}
    \begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{nd.jpeg}
\end{figure}
\end{frame}

\subsection*{Ins}
\begin{frame}{Intuitionistic Logic}
\begin{itemize}
    \item \textbf{Intuitionistic Logic} Also called Constructive Logic, reflects principles of constructive mathematics, where a statement is only true if a proof can be constructed.
    \item Omits some classical logic rules, such as the Law of Excluded Middle.
    \item Stronger requirement: to prove existence, a method or algorithm must be given.
    \item Proof assistants leverage this constructive approach for digital verification.
\end{itemize}
\end{frame}
 

\begin{frame}
    \begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{nid.jpeg}

\end{figure}
Inference Rules for Intuitionistic Logic
\end{frame}
\subsection*{$\lambda$-Calculus}
\begin{frame}{$\lambda$-Calculus and Type Theory}
\begin{itemize}
    \item \textbf{$\lambda$-Calculus}: A foundational system for defining and applying functions using abstraction and application.
    \item \textbf{Type Theory}: Assigns types to every term; ensures correctness of operations.
         \item \emph{Dependent types} allow types to depend on values, expressing complex logical properties.

    \item \textbf{Curry--Howard Correspondence}: 
    \begin{itemize}
        \item Propositions $\leftrightarrow$ Types
        \item Proofs $\leftrightarrow$ Programs
    \end{itemize}
    \item \emph{Dependent types} allow types to depend on values, expressing complex logical properties.
\end{itemize}
\end{frame}
\section{Architecture of proof assistant}
\begin{frame}{Architecture of a Proof Assistant}
\begin{itemize}
    \item \textbf{Kernel}: Minimal, trustworthy codebase enforcing logical rules and validating proofs.
    \item \textbf{Tactic Engine}: Helps build and automate proofs step by step.
    \item \textbf{Formal Proof Language}: Rigorously expresses definitions, statements, and proofs.
    \item \textbf{Libraries}: Collections of verified mathematical foundations for reuse.
    \item \textbf{User Interface}: IDEs and plugins for interactive, efficient proof development.
\end{itemize}
\end{frame}
\subsection*{Kernel}
\begin{frame}{Kernel: The Trusted Core}
\begin{itemize}
    \item The \textbf{kernel} is the minimal and most critical part of a proof assistant.
    \item It enforces the logical rules of the underlying formal system (e.g., type theory).
    \item Responsible for \textbf{validating every proof step} to guarantee correctness.
    \item Ensures \textbf{soundness and trustworthiness}; the rest of the system depends on its integrity.
    \item Typically very small and rigorously tested or formally verified to avoid bugs.
    \item Example: Agda’s kernel is written in Haskell and integrates normalization to check definitional equality.
\end{itemize}
\end{frame}
\subsection*{Tactic Engine}

\begin{frame}{Tactic Engine: Proof Construction Assistant}
\begin{itemize}
    \item The \textbf{tactic engine} supports users in constructing proofs interactively.
    \item It breaks complex proof goals into simpler subgoals using \textbf{proof strategies} called tactics.
    \item Provides \textbf{automation} for common proof patterns, speeding up proof development.
    \item Enables both \textbf{forward} and \textbf{backward} reasoning approaches.
    \item Even fully automated tactics rely on the kernel for final verification.
    \item Varies among assistants (Agda has minimal/no tactics, Coq and Lean have powerful tactic systems).
\end{itemize}
\end{frame}
\subsection*{ Language}

\begin{frame}{Formal Proof Language: Expressing Proofs Precisely}
\begin{itemize}
    \item This language allows expressing \textbf{definitions, propositions, and proofs} rigorously.
    \item Typically a \textbf{dependently typed language} so logical properties can be encoded as types.
    \item Provides \textbf{syntax and semantics} suitable for formal reasoning and machine checking.
    \item Enables users to write \textbf{human-readable yet unambiguous} formal proofs.
    \item Integrates smoothly with tactics and type checker to maintain correctness.
    \item Example languages: Agda’s core language, Coq’s Gallina, Lean’s dependent type language.
\end{itemize}
\end{frame}
\subsection*{Libraries}
\begin{frame}{Libraries: Reusable Verified Foundations}
\begin{itemize}
    \item Extensive collections of \textbf{formalized mathematics and algorithms} supporting new developments.
    \item Include \textbf{basic theories} such as arithmetic, algebra, logic, and set theory.
    \item Enable users to \textbf{build on existing verified results} without re-proving foundations.
    \item Libraries evolve and grow, fostering \textbf{collaboration and community sharing}.
    \item Well-maintained libraries reduce duplication and improve proof assistant adoption.
    \item Examples include Coq’s Standard Library, Agda Standard Library, Lean’s mathlib.
\end{itemize}
\end{frame}
\subsection*{User Interface}
\begin{frame}{User Interface: Proof Development Environment}
\begin{itemize}
    \item Provides \textbf{interactive tools} like IDEs, editor plugins, or command line interfaces.
    \item Features include \textbf{syntax highlighting, error reporting, real-time proof state visualization,} and \textbf{auto-completion}.
    \item Enhances \textbf{usability and productivity} for proof authors.
    \item Supports \textbf{integration with tactics and proof language} for seamless workflow.
    \item Examples: CoqIDE, Proof General, Emacs-mode for Agda, VS Code extensions.
    \item A good interface lowers the learning curve and makes formalization more accessible.
\end{itemize}
\end{frame}
\section{Comparative Study}
\begin{frame}{Comparative Table: Agda, Rocq (Coq), and Lean}
  
\begin{table}
\centering
\scalebox{0.75}{
    \begin{tabular}{|p{2cm}|p{4cm}|p{4cm}|p{4cm}|}
    \hline
    \small \textbf{Component} &  \small \textbf{Agda} & \small \textbf{Rocq (Coq)} & \small \textbf{Lean} \\
    \toprule
    \small \textbf{Proof Style} & \footnotesize Explicit term-based, manual proof writing & \footnotesize Tactic-based, automated backward reasoning & \footnotesize Both tactic-based and term-style \\

    \small \textbf{Kernel} & Minimal, written in Haskell, tight integration with normalization & Based on Calculus of Inductive Constructions (CIC), written in Coq (extracted to OCaml) & CIC-based, written in C++/C \\
    \small \textbf{Type Checking} & Bidirectional, transparent, normalization by evaluation & Bidirectional, heavy conversion, strong automation & Bidirectional, smart elaboration (coercion, backtracking, overloading) \\

    \small \textbf{Automation} & Limited (no tactics, minimal automation) & Extensive tactic engine and proof search & Advanced, seamless tactic/term mixing, smart elaborator \\

    \small \textbf{Use Cases} & Foundations, education, dependently typed programming & Large/complex formalizations, industrial-scale proofs & Research, education, combinatorial/mathematical formalizations \\
    \bottomrule
    \end{tabular}
}
\end{table}
\end{frame}

\section{Formalization Of Some proofs}
\subsection*{Defining Natural Numbers} 
    \begin{frame}[fragile]
        \frametitle{Eg: Defining Natural Numbers}
        \begin{verbatim}
           data N : Set where 
                Zero : N 
                suc : N -> N
        \end{verbatim}
    \end{frame}


\input{AuxiliaryFiles/Thanks}  
\end{document}